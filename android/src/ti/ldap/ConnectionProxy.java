/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ti.ldap;

import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.KrollFunction;

import android.util.Log;
import android.app.Activity;
import java.util.HashMap;
import java.util.ArrayList;
import java.lang.reflect.Array;
import java.net.URI;
import java.net.URISyntaxException;
import java.io.IOException;

import com.unboundid.ldap.sdk.LDAPConnection;
import com.unboundid.ldap.sdk.LDAPException;
import com.unboundid.ldap.sdk.SearchRequest;
import com.unboundid.ldap.sdk.SearchResult;
import com.unboundid.ldap.sdk.SearchResultEntry;
import com.unboundid.ldap.sdk.LDAPSearchException;
import com.unboundid.ldap.sdk.SearchScope;
import com.unboundid.ldap.sdk.BindResult;


@Kroll.proxy(creatableInModule=LdapModule.class)
public class ConnectionProxy extends KrollProxy
{
	// Standard Debugging variables
	private static final String LCAT = "TiLdap";
    private LDAPConnection ld = null;

    @Kroll.constant public static final int SUCCESS = 0;

    //@Kroll.constant public static final int OPT_PROTOCOL_VERSION, ??;

    @Kroll.constant public static final int SCOPE_BASE = SearchScope.BASE_INT_VALUE;
    @Kroll.constant public static final int SCOPE_ONELEVEL = SearchScope.ONE_INT_VALUE;
    @Kroll.constant public static final int SCOPE_SUBTREE = SearchScope.SUB_INT_VALUE;
    @Kroll.constant public static final int SCOPE_CHILDREN = SearchScope.SUBORDINATE_SUBTREE_INT_VALUE;
    @Kroll.constant public static final int SCOPE_DEFAULT = -1;

    @Kroll.constant public static final String ALL_USER_ATTRIBUTES = SearchRequest.ALL_USER_ATTRIBUTES;
    @Kroll.constant public static final String ALL_OPERATIONAL_ATTRIBUTES = SearchRequest.ALL_OPERATIONAL_ATTRIBUTES;
    @Kroll.constant public static final String NO_ATTRS = SearchRequest.NO_ATTRIBUTES;


	// Constructor
	public ConnectionProxy()
	{
		super();
		Log.d(LCAT, ">>>>> HERE <<<<<");
	}

	// Handle creation options
	@Override
	public void handleCreationDict(KrollDict options)
	{
		super.handleCreationDict(options);
	}

    @Kroll.method
    public int initialize(HashMap hm)
    {
        Log.d(LCAT, ">>>> initialize <<<");

        KrollDict args = new KrollDict(hm);

        int port = 389;
        String host = "";
        try {
            URI uri = new URI(args.optString("uri", "ldap://127.0.0.1"));
            // NOTE: Need to strip off 'ldap' scheme
            host = uri.getHost();
            port = uri.getPort();
            if (port == -1) {
                port = 389;
            }
        }
        catch (URISyntaxException e) {
            Log.e(LCAT, "Invalid uri specified");
        }

        Log.d(LCAT, "LDAP initialize with host: " + host + " and port: " + port);

        try {
            ld = new LDAPConnection(host, port);
        }
        catch (LDAPException e) {
            Log.e(LCAT, "Error occurred during LDAP initialization: " + e.toString());
            return -1;
        }

        return SUCCESS;
    }

    @Kroll.method
    public int simpleBind(HashMap hm)
    {
        Log.d(LCAT, ">>> simpleBind <<<");

        KrollDict args = new KrollDict(hm);

        String dn = args.getString("dn");
        String password = args.getString("password");

        try {
            BindResult bindResult = ld.bind(dn, password);
        }
        catch (LDAPException e) {
            Log.e(LCAT, "Error occurred in simple bind: " + e.toString());
            return -1;
        }

        return SUCCESS;
    }

    @Kroll.method
    public int unBind()
    {
        int result = 0;
        if (ld != null) {
            ld.close();
            ld = null;
        }

        return result;
    }

    @Kroll.method
    public Object search(HashMap hm)
    {
    //BUGBUG -- Think about whether the dn, filter should be dictionaries of
    //key/value pairs can the createEqualityFilter method should be used instead
    //of string
        KrollDict args = new KrollDict(hm);

        String dn = args.getString("dn");
        int scope = args.optInt("scope", SCOPE_DEFAULT);
        String filter = args.optString("filter", "(objectClass=*)");

        Object obj = args.get("attrs");
        ArrayList<String> attrs = null;
        if (obj != null) {
            if (obj.getClass().isArray()) {
                Object[] arr = (Object[])obj;
                attrs = new ArrayList<String>();
                for (int i=0; i<arr.length; i++) {
                    attrs.add((String)arr[i]);
                }
            }
        }

        Boolean attrsOnly = args.optBoolean("attrsOnly", false);
        KrollFunction callback = (KrollFunction)args.get("callback");
        try {
            SearchRequest searchRequest = new SearchRequest(dn,
                SearchScope.definedValueOf(scope), filter);
            searchRequest.setTypesOnly(attrsOnly);
            if (attrs != null) {
                searchRequest.setAttributes(attrs);
            }

            SearchResult searchResult = ld.search(searchRequest);

            //BUGBUG Create Proxy
            for (SearchResultEntry entry : searchResult.getSearchEntries())
            {
                Log.w(LCAT,"Search Result: " + entry.toString());
            }
        }
        catch (LDAPSearchException lse) {
            Log.e(LCAT,"Error occurred in search: " + lse.toString());
            return null;
        } catch (LDAPException e) {
            Log.e(LCAT,"Error occurred in search: " + e.toString());
            return null;
        }



        //BUGBUG
        return null;
    }
}